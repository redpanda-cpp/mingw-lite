diff --git a/src/tbox/platform/windows/interface/kernel32.c b/src/tbox/platform/windows/interface/kernel32.c
index 603737dc..833f7531 100644
--- a/src/tbox/platform/windows/interface/kernel32.c
+++ b/src/tbox/platform/windows/interface/kernel32.c
@@ -68,6 +68,8 @@ static tb_bool_t tb_kernel32_instance_init(tb_kernel32_ref_t kernel32)
     TB_INTERFACE_LOAD(kernel32, CopyFileExW);
     TB_INTERFACE_LOAD(kernel32, PeekConsoleInputW);
     TB_INTERFACE_LOAD(kernel32, PeekNamedPipe);
+    TB_INTERFACE_LOAD(kernel32, VerifyVersionInfoW);
+    TB_INTERFACE_LOAD(kernel32, VerSetConditionMask);
 #if defined(TB_COMPILER_IS_MSVC) && TB_COMPILER_VERSION_BT(16, 0)
     TB_INTERFACE_LOAD(kernel32, GetLogicalProcessorInformationEx);
 #endif
diff --git a/src/tbox/platform/windows/interface/kernel32.h b/src/tbox/platform/windows/interface/kernel32.h
index ec7f6402..500a9b6d 100644
--- a/src/tbox/platform/windows/interface/kernel32.h
+++ b/src/tbox/platform/windows/interface/kernel32.h
@@ -213,6 +213,18 @@ typedef BOOL (WINAPI* tb_kernel32_PeekNamedPipe_t)(
     LPDWORD             lpTotalBytesAvail,
     LPDWORD             lpBytesLeftThisMessage);
 
+// the VerifyVersionInfoW func type
+typedef BOOL (WINAPI* tb_kernel32_VerifyVersionInfoW_t)(
+    LPOSVERSIONINFOEXW lpVersionInformation,
+    DWORD              dwTypeMask,
+    DWORDLONG          dwlConditionMask);
+
+// the VerSetConditionMask func type
+typedef ULONGLONG (WINAPI* tb_kernel32_VerSetConditionMask_t)(
+    ULONGLONG ConditionMask,
+    DWORD     TypeMask,
+    BYTE      Condition);
+
 // the kernel32 interfaces type
 typedef struct __tb_kernel32_t
 {
@@ -300,6 +312,12 @@ typedef struct __tb_kernel32_t
     // PeekNamedPipe
     tb_kernel32_PeekNamedPipe_t                         PeekNamedPipe;
 
+    // VerifyVersionInfoW
+    tb_kernel32_VerifyVersionInfoW_t                    VerifyVersionInfoW;
+
+    // VerSetConditionMask
+    tb_kernel32_VerSetConditionMask_t                   VerSetConditionMask;
+
     // GetLogicalProcessorInformationEx
 #if defined(TB_COMPILER_IS_MSVC) && TB_COMPILER_VERSION_BT(16, 0)
     tb_kernel32_GetLogicalProcessorInformationEx_t      GetLogicalProcessorInformationEx;
diff --git a/src/tbox/platform/windows/process.c b/src/tbox/platform/windows/process.c
index 11740b26..f0ff0cf7 100644
--- a/src/tbox/platform/windows/process.c
+++ b/src/tbox/platform/windows/process.c
@@ -244,6 +244,67 @@ static tb_void_t tb_process_args_append(tb_string_ref_t result, tb_char_t const*
     if (wrap_quote) tb_string_chrcat(result, '\"');
 }
 
+static tb_bool_t tb_process_is_win7_or_lower(tb_noarg_t)
+{
+    // Cache the result: -1 means uninitialized, 0 means false, 1 means true
+    static tb_long_t s_is_win7_or_lower = -1;
+    if (s_is_win7_or_lower != -1)
+        return s_is_win7_or_lower == 1;
+    tb_kernel32_ref_t kernel32 = tb_kernel32();
+    if (!kernel32 || !kernel32->VerifyVersionInfoW || !kernel32->VerSetConditionMask)
+    {
+        s_is_win7_or_lower = 0;
+        return tb_false;
+    }
+    OSVERSIONINFOEXW osvi = {0};
+    osvi.dwOSVersionInfoSize = sizeof(osvi);
+    DWORDLONG const mask = kernel32->VerSetConditionMask(
+        kernel32->VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+        VER_MINORVERSION, VER_GREATER_EQUAL);
+    osvi.dwMajorVersion = 6;
+    osvi.dwMinorVersion = 2;
+    tb_bool_t is_win7 = (kernel32->VerifyVersionInfoW(&osvi, VER_MAJORVERSION | VER_MINORVERSION, mask) == FALSE &&
+                         GetLastError() == ERROR_OLD_WIN_VERSION);         
+    s_is_win7_or_lower = is_win7 ? 1 : 0;
+    return is_win7;
+}
+
+/* @see https://github.com/xmake-io/xmake/issues/7330
+ * https://github.com/chromium/crashpad/commit/9b92d2fb7101bae2af9bb5447227df296b37b56a
+ */
+static tb_bool_t tb_process_is_inheritable_handle(HANDLE handle)
+{
+    tb_check_return_val(handle && handle != INVALID_HANDLE_VALUE, tb_false);
+    
+    if (tb_process_is_win7_or_lower()) {
+        // File handles (FILE_TYPE_DISK) and pipe handles (FILE_TYPE_PIPE) are known
+        // to be inheritable. Console handles (FILE_TYPE_CHAR) are not inheritable via
+        // PROC_THREAD_ATTRIBUTE_HANDLE_LIST. See
+        // @ref https://codereview.chromium.org/1473793002
+        DWORD handle_type = GetFileType(handle);
+        return handle_type == FILE_TYPE_DISK || handle_type == FILE_TYPE_PIPE;
+    }
+    
+    // On Win 8+, console handles are safe to inherit via PROC_THREAD_ATTRIBUTE_HANDLE_LIST
+    return tb_true; 
+}
+
+static tb_void_t tb_process_add_inheritable_handle(HANDLE* handles, DWORD* count, DWORD max_count, HANDLE handle)
+{
+    if (tb_process_is_inheritable_handle(handle))
+    {
+        // There doesn't seem to be any documentation of this, but if there's a handle
+        // duplicated in this list, CreateProcess() fails with ERROR_INVALID_PARAMETER.
+        for (DWORD i = 0; i < *count; i++)
+        {
+            if (handles[i] == handle)
+                return;
+        }
+        if (*count < max_count)
+            handles[(*count)++] = handle;
+    }
+}
+
 /* //////////////////////////////////////////////////////////////////////////////////////
  * implementation
  */
@@ -424,7 +485,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdInput, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdInput;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdInput);
                 process->file_handles[process->file_handles_count++] = hStdInput;
                 process->psi->hStdInput = hStdInput;
             }
@@ -436,7 +497,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdInput, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdInput;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdInput);
                 process->psi->hStdInput = hStdInput;
             }
 
@@ -456,7 +517,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdOutput, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdOutput;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdOutput);
                 process->file_handles[process->file_handles_count++] = hStdOutput;
                 process->psi->hStdOutput = hStdOutput;
             }
@@ -468,7 +529,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdOutput, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdOutput;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdOutput);
                 process->psi->hStdOutput = hStdOutput;
             }
 
@@ -488,7 +549,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdError, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdError;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdError);
                 process->file_handles[process->file_handles_count++] = hStdError;
                 process->psi->hStdError = hStdError;
             }
@@ -511,7 +572,7 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
 
                 // enable inherit
                 tb_kernel32()->SetHandleInformation(hStdError, HANDLE_FLAG_INHERIT, TRUE);
-                handlesToInherit[handlesToInheritCount++] = hStdError;
+                tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdError);
                 process->psi->hStdError = hStdError;
             }
         }
@@ -569,16 +630,14 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
                         process->psi->hStdInput = hDupInput;
                         process->file_handles[process->file_handles_count++] = hDupInput;
                         // add to handlesToInherit list so it can be inherited when using PROC_THREAD_ATTRIBUTE_HANDLE_LIST
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hDupInput;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hDupInput);
                     }
                     else
                     {
                         // if duplication fails, try to make original inheritable (may affect parent)
                         tb_kernel32()->SetHandleInformation(hStdInput, HANDLE_FLAG_INHERIT, TRUE);
                         process->psi->hStdInput = hStdInput;
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hStdInput;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdInput);
                     }
                 }
             }
@@ -594,16 +653,14 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
                         process->psi->hStdOutput = hDupOutput;
                         process->file_handles[process->file_handles_count++] = hDupOutput;
                         // add to handlesToInherit list so it can be inherited when using PROC_THREAD_ATTRIBUTE_HANDLE_LIST
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hDupOutput;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hDupOutput);
                     }
                     else
                     {
                         // if duplication fails, try to make original inheritable (may affect parent)
                         tb_kernel32()->SetHandleInformation(hStdOutput, HANDLE_FLAG_INHERIT, TRUE);
                         process->psi->hStdOutput = hStdOutput;
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hStdOutput;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdOutput);
                     }
                 }
             }
@@ -619,16 +676,14 @@ tb_process_ref_t tb_process_init_cmd(tb_char_t const* cmd, tb_process_attr_ref_t
                         process->psi->hStdError = hDupError;
                         process->file_handles[process->file_handles_count++] = hDupError;
                         // add to handlesToInherit list so it can be inherited when using PROC_THREAD_ATTRIBUTE_HANDLE_LIST
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hDupError;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hDupError);
                     }
                     else
                     {
                         // if duplication fails, try to make original inheritable (may affect parent)
                         tb_kernel32()->SetHandleInformation(hStdError, HANDLE_FLAG_INHERIT, TRUE);
                         process->psi->hStdError = hStdError;
-                        if (handlesToInheritCount < sizeof(handlesToInherit) / sizeof(handlesToInherit[0]))
-                            handlesToInherit[handlesToInheritCount++] = hStdError;
+                        tb_process_add_inheritable_handle(handlesToInherit, &handlesToInheritCount, tb_arrayn(handlesToInherit), hStdError);
                     }
                 }
             }
